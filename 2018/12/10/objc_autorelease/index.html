<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="objc,">










<meta name="description" content="相信多数人都清楚AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。 让我们来学习下autorelease底层是如何实现的 本文基于objc4-750 点此下载">
<meta name="keywords" content="objc">
<meta property="og:type" content="article">
<meta property="og:title" content="objc源码解析 | autorelease">
<meta property="og:url" content="https://yonglefu.github.io/2018/12/10/objc_autorelease/index.html">
<meta property="og:site_name" content="Yongle の notes">
<meta property="og:description" content="相信多数人都清楚AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。 让我们来学习下autorelease底层是如何实现的 本文基于objc4-750 点此下载">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-11T14:06:50.915Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="objc源码解析 | autorelease">
<meta name="twitter:description" content="相信多数人都清楚AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。 让我们来学习下autorelease底层是如何实现的 本文基于objc4-750 点此下载">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yonglefu.github.io/2018/12/10/objc_autorelease/">





  <title>objc源码解析 | autorelease | Yongle の notes</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yongle の notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">技术宅 iOS开发</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yonglefu.github.io/2018/12/10/objc_autorelease/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yongle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yongle の notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">objc源码解析 | autorelease</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-10T00:00:00+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/10/objc_autorelease/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/12/10/objc_autorelease/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>相信多数人都清楚AutoreleasePool（自动释放池）是OC中的一种内存自动回收机制，它可以延迟加入AutoreleasePool中的变量release的时机。<br>在正常情况下，创建的变量会在超出其作用域的时候release，但是如果将变量加入AutoreleasePool，那么release将延迟执行。</p>
<p>让我们来学习下autorelease底层是如何实现的</p>
<p>本文基于objc4-750 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">点此下载</a></p>
<p>先来看下@autoreleasepool{ } <a href="https://www.jianshu.com/p/1b66c4d47cd7" target="_blank" rel="noopener">参考链接</a></p>
<p>经过clang -rewrite-objc之后<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> * objc_autoreleasePoolPush(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123; objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>根据构造函数和析构函数的特点（自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用），代码简化为<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    ...</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单个自动释放池的执行过程就是objc_autoreleasePoolPush() —&gt; [object autorelease] —&gt; objc_autoreleasePoolPop(void *)</p>
<p>来看下objc_autoreleasePoolPush<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> *dest;</span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看下autorelease方法<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>prepareOptimizedReturn部分放到最后分析，autorelease同push方法一样最后也是调用autoreleaseFast</p>
<p>先来看下AutoreleasePoolPage结构<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span></span><br><span class="line">    <span class="comment">// pushed and it has never contained any objects. This saves memory </span></span><br><span class="line">    <span class="comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span></span><br><span class="line">    <span class="comment">// never uses them.</span></span><br><span class="line"><span class="meta">#   define EMPTY_POOL_PLACEHOLDER ((id*)1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#   define POOL_BOUNDARY nil</span></span><br><span class="line">    <span class="keyword">static</span> pthread_key_t <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">    <span class="keyword">static</span> uint8_t <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> SIZE = </span><br><span class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">static</span> size_t <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(<span class="keyword">id</span>);</span><br><span class="line"></span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    <span class="keyword">id</span> *next;</span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SIZE-sizeof(*this) bytes of contents follow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> * operator new(size_t size) &#123;</span><br><span class="line">        <span class="keyword">return</span> malloc_zone_memalign(malloc_default_zone(), SIZE, SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> operator delete(<span class="keyword">void</span> * p) &#123;</span><br><span class="line">        <span class="keyword">return</span> free(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> protect() &#123;</span><br><span class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        mprotect(<span class="keyword">this</span>, SIZE, PROT_READ);</span><br><span class="line">        check();</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> unprotect() &#123;</span><br><span class="line"><span class="meta">#if PROTECT_AUTORELEASEPOOL</span></span><br><span class="line">        check();</span><br><span class="line">        mprotect(<span class="keyword">this</span>, SIZE, PROT_READ | PROT_WRITE);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage(AutoreleasePoolPage *newParent) </span><br><span class="line">        : magic(), next(begin()), thread(pthread_self()),</span><br><span class="line">          parent(newParent), child(<span class="literal">nil</span>), </span><br><span class="line">          depth(parent ? <span class="number">1</span>+parent-&gt;depth : <span class="number">0</span>), </span><br><span class="line">          hiwat(parent ? parent-&gt;hiwat : <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">            parent-&gt;check();</span><br><span class="line">            assert(!parent-&gt;child);</span><br><span class="line">            parent-&gt;unprotect();</span><br><span class="line">            parent-&gt;child = <span class="keyword">this</span>;</span><br><span class="line">            parent-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        protect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~AutoreleasePoolPage() </span><br><span class="line">    &#123;</span><br><span class="line">        check();</span><br><span class="line">        unprotect();</span><br><span class="line">        assert(empty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">        <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">        assert(!child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> * begin() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">id</span> *) ((uint8_t *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> * end() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">id</span> *) ((uint8_t *)<span class="keyword">this</span>+SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> empty() &#123;</span><br><span class="line">        <span class="keyword">return</span> next == begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> full() &#123; </span><br><span class="line">        <span class="keyword">return</span> next == end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> lessThanHalfFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> (next - begin() &lt; (end() - begin()) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define BYTE_SIZE		8		/* byte size in bits */</span></span><br><span class="line"><span class="meta">#define I386_PGBYTES	4096    /* bytes per 80386 page */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define	PAGE_SIZE		I386_PGBYTES</span></span><br><span class="line"><span class="meta">#define	PAGE_MASK		(PAGE_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define PAGE_MAX_SIZE   PAGE_SIZE</span></span><br></pre></td></tr></table></figure></p>
<p>// This saves memory when the top level (i.e. libdispatch) pushes and pops pools but never uses them.<br>EMPTY_POOL_PLACEHOLDER 空池占位，当pool被push/pop但从来不使用时用于节约内存</p>
<p>POOL_BOUNDARY是一个边界对象nil, 原来的名称是POOL_SENTINEL哨兵对象, 用来标志每次push时边界</p>
<p>PAGE_MAX_SIZE = 4096 虚拟内存每个扇区4096个字节, 4K对齐</p>
<p>parent 父节点 指向前一个page<br>child 子节点 指向下一个page<br>可以看出这是以AutoreleasePoolPage为Node的双向链表结构 </p>
<p>next指针指向将要add的位置</p>
<p>magic 检查校验完整性的变量<br>thread page当前所在的线程，AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）<br>depth 链表的深度，节点个数<br>hiwat 即 high water mark 数据容纳的上限</p>
<p>begin(), 初始化之后返回POOL_BOUNDARY之后的位置<br>end()返回page的末端<br>next == begin()时，即只有POOL_BOUNDARY，empty<br>next == end()时,  Page空间都被使用了, full</p>
<p>接着看autoreleaseFast<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取当前hotPage<br>当前hotPage存在，Page满时，加到当前hotPage，否则执行autoreleaseFullPage<br>当前hotPage不存在则执行autoreleaseNoPage  一个page都没有</p>
<p>来看下page-&gt;add<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    <span class="keyword">id</span> *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hotage满时<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    assert(page == hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>依次遍历hotPage的可用child，未找到时新创建一个page<br>重新设置hotPage，添加对象</p>
<p>来看下autoreleaseNoPage<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// "No page" could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    assert(!hotPage());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a second pool over the empty placeholder pool</span></span><br><span class="line">        <span class="comment">// or pushing the first object into the empty placeholder pool.</span></span><br><span class="line">        <span class="comment">// Before doing that, push a pool boundary on behalf of the pool </span></span><br><span class="line">        <span class="comment">// that is currently represented by the empty placeholder.</span></span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        <span class="comment">// We are pushing an object with no pool in place, </span></span><br><span class="line">        <span class="comment">// and no-pool debugging was requested by environment.</span></span><br><span class="line">        _objc_inform(<span class="string">"MISSING POOLS: (%p) Object %p of class %s "</span></span><br><span class="line">                        <span class="string">"autoreleased with no pool in place - "</span></span><br><span class="line">                        <span class="string">"just leaking - break on "</span></span><br><span class="line">                        <span class="string">"objc_autoreleaseNoPool() to debug"</span>, </span><br><span class="line">                        pthread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> setEmptyPoolPlaceholder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder'd pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder'd pool.</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>push时，当obj==POOL_BOUNDARY，执行setEmptyPoolPlaceholder<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span>* setEmptyPoolPlaceholder()</span><br><span class="line">&#123;</span><br><span class="line">    assert(tls_get_direct(key) == <span class="literal">nil</span>);</span><br><span class="line">    tls_set_direct(key, (<span class="keyword">void</span> *)EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">return</span> EMPTY_POOL_PLACEHOLDER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> haveEmptyPoolPlaceholder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> *tls = (<span class="keyword">id</span> *)tls_get_direct(key);</span><br><span class="line">    <span class="keyword">return</span> (tls == EMPTY_POOL_PLACEHOLDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *tls_get_direct(tls_key_t k) </span><br><span class="line">&#123; </span><br><span class="line">    assert(is_valid_direct_key(k));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pthread_has_direct_tsd()) &#123;</span><br><span class="line">        <span class="keyword">return</span> _pthread_getspecific_direct(k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_getspecific(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> tls_set_direct(tls_key_t k, <span class="keyword">void</span> *value) </span><br><span class="line">&#123; </span><br><span class="line">    assert(is_valid_direct_key(k));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pthread_has_direct_tsd()) &#123;</span><br><span class="line">        _pthread_setspecific_direct(k, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_setspecific(k, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pthread_getpecific和pthread_setspecific同个线程中共享数据<br>static pthread_key_t const key = AUTORELEASE_POOL_KEY;<br>AUTORELEASE_POOL_KEY的值保存在TLS(即Thread Local Storage)上</p>
<p>EMPTY_POOL_PLACEHOLDER前面提过为空池占位，即该线程在NoPage时的push操作并不会立即创建AutoreleasePoolPage对象，等到添加首个autorelease对象时方才创建该线程首个Page、设置hotPage、添加POOL_BOUNDARY、添加autorelease对象，其实就是按惰性的原则处理</p>
<p>来看下objc_autoreleasePoolPop<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) </span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    <span class="keyword">id</span> *stop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">            <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">            <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">            pop(coldPage()-&gt;begin());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            setHotPage(<span class="literal">nil</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = pageForPointer(token);</span><br><span class="line">    stop = (<span class="keyword">id</span> *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintPoolHiwat) printHiwat();</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children</span></span><br><span class="line">    <span class="keyword">if</span> (DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top) </span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(<span class="literal">nil</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line">...</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure></p>
<p>当pop的 token == (void*)EMPTY_POOL_PLACEHOLDER，释放到最顶层coldPage()-&gt;begin()<br>page-&gt;releaseUntil(stop); //这里对stop进行了检查应为coldPage()-&gt;begin() 或者 指向的是POOL_BOUNDARY<br>releaseUntil从当前hotPage的next-1 一直释放到stop, 对其中的非POOL_BOUNDARY调用objc_release</p>
<p>来看下releaseUntil的具体实现<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> releaseUntil(<span class="keyword">id</span> *stop) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects</span></span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can't prove it</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        <span class="keyword">id</span> obj = *--page-&gt;next;</span><br><span class="line">        memset((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// Not recursive: we don’t want to blow out the stack<br>// if a thread accumulates a stupendous amount of garbage<br>不做递归调用，当线程积累了大量垃圾时，有很多page的情况</p>
<p>static uint8_t const SCRIBBLE = 0xA3;  // 0xA3A3A3A3 after releasing<br>对当前hotpage进行一一释放，重置内存为0xA3A3A3A3，直到当前hotPage为空时，更新hotPage为parent节点继续释放对象  </p>
<p>接着看之前pop最后的部分，忽略调试部分代码, 剩下为清理page对象<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">    <span class="comment">// hysteresis: keep one empty child if page is more than half full</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">        page-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">        page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前page有子节点并且 使用超过一半时保留一个空的子节点</p>
<p>来看下kill部分<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> kill() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don't want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = <span class="literal">nil</span>;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环遍历进行delete操作</p>
<h2 id="关于NSAutoreleasePool"><a href="#关于NSAutoreleasePool" class="headerlink" title="关于NSAutoreleasePool"></a>关于NSAutoreleasePool</h2><p>MRC下使用，对象释放时机为pool release或者drain的时候</p>
<p>If you use Automatic Reference Counting (ARC), you cannot use autorelease pools directly. Instead, you use @autoreleasepool blocks. For example, in place of:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="comment">// Code benefitting from a local autorelease pool.</span></span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure></p>
<p>you would write:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// Code benefitting from a local autorelease pool.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@autoreleasepool blocks are more efficient than using an instance of NSAutoreleasePool directly; you can also use them even if you do not use ARC.</p>
<p>这部分没看到源代码，官方文档介绍@autoreleasepool也可以在MRC下使用，而且效率会更高 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool" target="_blank" rel="noopener">NSAutoreleasePool</a></p>
<h2 id="关于RunLoop的部分"><a href="#关于RunLoop的部分" class="headerlink" title="关于RunLoop的部分"></a>关于RunLoop的部分</h2><p>苹果在主线程RunLoop里注册了两个Observer：<br>第一个Observer监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其order是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个Observer监视了两个事件： BeforeWaiting(准备进入睡眠) 和 Exit(即将退出Loop)，<br>BeforeWaiting(准备进入睡眠)时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；<br>Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>即</p>
<ul>
<li>Entry -&gt; BeforeWaiting   其间调用autorelease方法的对象自动释放的时机为BeforeWaiting</li>
<li>BeforeWaiting -&gt;  Exit   其间调用autorelease方法的对象自动释放的时机为Exit</li>
</ul>
<h2 id="关于autorelease调用优化部分"><a href="#关于autorelease调用优化部分" class="headerlink" title="关于autorelease调用优化部分"></a>关于autorelease调用优化部分</h2><p>即前面遇到的代码prepareOptimizedReturn, 笔者通俗的理解就是对以下两种情况进行了优化<br>ReturnAtPlus0情况，原本需要调用objc_autorelease(objc_retain(obj))，然后调用objc_release(obj)，则这两次操作都直接返回obj<br>ReturnAtPlus1情况，原本需要调用objc_autorelease(obj)，然后调用objc_retain(obj)，则这两次操作都直接返回obj  </p>
<p>来看下实现，首先是准备优化<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare a value at +1 for return through a +0 autoreleasing convention.</span></span><br><span class="line"><span class="keyword">id</span> objc_autoreleaseReturnValue(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_autorelease(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare a value at +0 for return through a +0 autoreleasing convention.</span></span><br><span class="line"><span class="keyword">id</span> objc_retainAutoreleaseReturnValue(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus0)) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_retainAutoreleaseAndReturn(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to prepare for optimized return with the given disposition (+0 or +1).</span></span><br><span class="line"><span class="comment">// Returns true if the optimized path is successful.</span></span><br><span class="line"><span class="comment">// Otherwise the return value must be retained and/or autoreleased as usual.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">prepareOptimizedReturn(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">    assert(getReturnDisposition() == ReturnAtPlus0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callerAcceptsOptimizedReturn(__builtin_return_address(<span class="number">0</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disposition) setReturnDisposition(disposition);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to accept an optimized return.</span></span><br><span class="line"><span class="comment">// Returns the disposition of the returned object (+0 or +1).</span></span><br><span class="line"><span class="comment">// An un-optimized return is +0.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line">acceptOptimizedReturn()</span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition = getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  <span class="comment">// reset to the unoptimized state</span></span><br><span class="line">    <span class="keyword">return</span> disposition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">void</span> </span><br><span class="line">setReturnDisposition(ReturnDisposition disposition)</span><br><span class="line">&#123;</span><br><span class="line">    tls_set_direct(RETURN_DISPOSITION_KEY, (<span class="keyword">void</span>*)(uintptr_t)disposition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>builtin_return_address(0)表示当前函数体返回地址, 也就是让被调用者在函数返回后有机会搞事情<br>callerAcceptsOptimizedReturn(</strong>builtin_return_address(0)) 检查Caller调用方是否接受优化<br>如果接受后将disposition值保存在TLS上</p>
<p>Caller调用方是否接受优化在arm64的实现<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">bool</span> </span><br><span class="line">callerAcceptsOptimizedReturn(<span class="keyword">const</span> <span class="keyword">void</span> *ra)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fd 03 1d aa    mov fp, fp</span></span><br><span class="line">    <span class="comment">// arm64 instructions are well-aligned</span></span><br><span class="line">    <span class="keyword">if</span> (*(uint32_t *)ra == <span class="number">0xaa1d03fd</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回地址等于0xaa1d03fd就接受了，这是为虾米</p>
<p>是不是只有Tagged pointer的对象才会进行优化<br>  Tagged pointer objects do participate in the optimized return scheme,<br>  because it saves message sends. They are not entered in the autorelease<br>  pool in the unoptimized case.</p>
<p>Caller调用方接受实现,<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Try to accept an optimized return.</span></span><br><span class="line"><span class="comment">// Returns the disposition of the returned object (+0 or +1).</span></span><br><span class="line"><span class="comment">// An un-optimized return is +0.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE ReturnDisposition </span><br><span class="line">acceptOptimizedReturn()</span><br><span class="line">&#123;</span><br><span class="line">    ReturnDisposition disposition = getReturnDisposition();</span><br><span class="line">    setReturnDisposition(ReturnAtPlus0);  <span class="comment">// reset to the unoptimized state</span></span><br><span class="line">    <span class="keyword">return</span> disposition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept a value returned through a +0 autoreleasing convention for use at +1.</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_retainAutoreleasedReturnValue(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (acceptOptimizedReturn() == ReturnAtPlus1) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_retain(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Accept a value returned through a +0 autoreleasing convention for use at +0.</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_unsafeClaimAutoreleasedReturnValue(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (acceptOptimizedReturn() == ReturnAtPlus0) <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objc_releaseAndReturn(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> </span><br><span class="line">objc_releaseAndReturn(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    objc_release(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从TLS上取值，如果满足相应的情况则直接返回obj</p>
<p>小结，一个线程首次调用objc_autoreleasePoolPush创建一个空池占用, 添加首个autorelease对象时才创建首个Page<br>调用objc_autoreleasePoolPop(void *token)释放对象<br>此时token应为2种情况</p>
<ol>
<li>token == EMPTY_POOL_PLACEHOLDER 释放整个自动释放池</li>
<li>token指向一个POOL_BOUNDARY，释放到该边界</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/objc/" rel="tag"># objc</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/09/objc_weak/" rel="next" title="objc源码解析 | weak实现">
                <i class="fa fa-chevron-left"></i> objc源码解析 | weak实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yongle</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于NSAutoreleasePool"><span class="nav-number">1.</span> <span class="nav-text">关于NSAutoreleasePool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于RunLoop的部分"><span class="nav-number">2.</span> <span class="nav-text">关于RunLoop的部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于autorelease调用优化部分"><span class="nav-number">3.</span> <span class="nav-text">关于autorelease调用优化部分</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yongle</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://yonglefu.github.io/2018/12/10/objc_autorelease/';
          this.page.identifier = '2018/12/10/objc_autorelease/';
          this.page.title = 'objc源码解析 | autorelease';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
